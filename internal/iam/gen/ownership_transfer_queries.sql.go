// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ownership_transfer_queries.sql

package iam_db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const batchTransferEnvironmentRoleBindingOwnership = `-- name: BatchTransferEnvironmentRoleBindingOwnership :exec
UPDATE role_bindings
SET user_id = $2,
    updated_at = now()
WHERE resource_type = 'environment'
  AND resource_id = ANY($1::uuid[])
  AND role = 'owner'
`

type BatchTransferEnvironmentRoleBindingOwnershipParams struct {
	Column1 []uuid.UUID   `json:"column_1"`
	UserID  uuid.NullUUID `json:"user_id"`
}

// Transfer ownership of multiple environments by updating role bindings
func (q *Queries) BatchTransferEnvironmentRoleBindingOwnership(ctx context.Context, arg BatchTransferEnvironmentRoleBindingOwnershipParams) error {
	_, err := q.db.ExecContext(ctx, batchTransferEnvironmentRoleBindingOwnership, pq.Array(arg.Column1), arg.UserID)
	return err
}

const batchTransferSecretGroupRoleBindingOwnership = `-- name: BatchTransferSecretGroupRoleBindingOwnership :exec

UPDATE role_bindings
SET user_id = $2,
    updated_at = now()
WHERE resource_type = 'secret_group'
  AND resource_id = ANY($1::uuid[])
  AND role = 'owner'
`

type BatchTransferSecretGroupRoleBindingOwnershipParams struct {
	Column1 []uuid.UUID   `json:"column_1"`
	UserID  uuid.NullUUID `json:"user_id"`
}

// ============================================================================
// 4. BATCH OWNERSHIP TRANSFER OPERATIONS
// ============================================================================
// Transfer ownership of multiple secret groups by updating role bindings
func (q *Queries) BatchTransferSecretGroupRoleBindingOwnership(ctx context.Context, arg BatchTransferSecretGroupRoleBindingOwnershipParams) error {
	_, err := q.db.ExecContext(ctx, batchTransferSecretGroupRoleBindingOwnership, pq.Array(arg.Column1), arg.UserID)
	return err
}

const createEnvironmentOwnershipRoleBinding = `-- name: CreateEnvironmentOwnershipRoleBinding :exec
INSERT INTO role_bindings (user_id, role, resource_type, resource_id, organization_id, secret_group_id, environment_id)
SELECT $2, 'owner', 'environment', $1, sg.organization_id, e.secret_group_id, $1
FROM environments e
INNER JOIN secret_groups sg ON e.secret_group_id = sg.id
WHERE e.id = $1
  AND NOT EXISTS (
    SELECT 1 FROM role_bindings rb 
    WHERE rb.resource_type = 'environment' 
      AND rb.resource_id = $1 
      AND rb.role = 'owner'
  )
`

type CreateEnvironmentOwnershipRoleBindingParams struct {
	ResourceID uuid.UUID     `json:"resource_id"`
	UserID     uuid.NullUUID `json:"user_id"`
}

// Create an ownership role binding for an environment if it doesn't exist
func (q *Queries) CreateEnvironmentOwnershipRoleBinding(ctx context.Context, arg CreateEnvironmentOwnershipRoleBindingParams) error {
	_, err := q.db.ExecContext(ctx, createEnvironmentOwnershipRoleBinding, arg.ResourceID, arg.UserID)
	return err
}

const createSecretGroupOwnershipRoleBinding = `-- name: CreateSecretGroupOwnershipRoleBinding :exec

INSERT INTO role_bindings (user_id, role, resource_type, resource_id, organization_id, secret_group_id)
SELECT $2, 'owner', 'secret_group', $1, sg.organization_id, $1
FROM secret_groups sg
WHERE sg.id = $1
  AND NOT EXISTS (
    SELECT 1 FROM role_bindings rb 
    WHERE rb.resource_type = 'secret_group' 
      AND rb.resource_id = $1 
      AND rb.role = 'owner'
  )
`

type CreateSecretGroupOwnershipRoleBindingParams struct {
	ResourceID uuid.UUID     `json:"resource_id"`
	UserID     uuid.NullUUID `json:"user_id"`
}

// ============================================================================
// 5. CREATE OWNERSHIP ROLE BINDINGS IF THEY DON'T EXIST
// ============================================================================
// Create an ownership role binding for a secret group if it doesn't exist
func (q *Queries) CreateSecretGroupOwnershipRoleBinding(ctx context.Context, arg CreateSecretGroupOwnershipRoleBindingParams) error {
	_, err := q.db.ExecContext(ctx, createSecretGroupOwnershipRoleBinding, arg.ResourceID, arg.UserID)
	return err
}

const getEnvironmentsWithGroupRoleBindings = `-- name: GetEnvironmentsWithGroupRoleBindings :many
SELECT DISTINCT
    e.id,
    e.name,
    e.description,
    e.secret_group_id,
    sg.organization_id,
    e.created_at,
    e.updated_at
FROM environments e
INNER JOIN secret_groups sg ON e.secret_group_id = sg.id
INNER JOIN role_bindings rb ON e.id = rb.resource_id
INNER JOIN user_group_members ugm ON rb.user_id = ugm.user_id
WHERE e.secret_group_id = $1
  AND rb.resource_type = 'environment'
  AND ugm.user_group_id = $2
  AND rb.group_id IS NULL
`

type GetEnvironmentsWithGroupRoleBindingsParams struct {
	SecretGroupID uuid.UUID `json:"secret_group_id"`
	UserGroupID   uuid.UUID `json:"user_group_id"`
}

type GetEnvironmentsWithGroupRoleBindingsRow struct {
	ID             uuid.UUID      `json:"id"`
	Name           string         `json:"name"`
	Description    sql.NullString `json:"description"`
	SecretGroupID  uuid.UUID      `json:"secret_group_id"`
	OrganizationID uuid.UUID      `json:"organization_id"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

// Find all environments where members of the revoked group have role bindings
func (q *Queries) GetEnvironmentsWithGroupRoleBindings(ctx context.Context, arg GetEnvironmentsWithGroupRoleBindingsParams) ([]GetEnvironmentsWithGroupRoleBindingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnvironmentsWithGroupRoleBindings, arg.SecretGroupID, arg.UserGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnvironmentsWithGroupRoleBindingsRow
	for rows.Next() {
		var i GetEnvironmentsWithGroupRoleBindingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.SecretGroupID,
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnvironmentsWithUserRoleBindings = `-- name: GetEnvironmentsWithUserRoleBindings :many
SELECT 
    e.id,
    e.name,
    e.description,
    e.secret_group_id,
    sg.organization_id,
    e.created_at,
    e.updated_at
FROM environments e
INNER JOIN secret_groups sg ON e.secret_group_id = sg.id
INNER JOIN role_bindings rb ON e.id = rb.resource_id
WHERE e.secret_group_id = $1
  AND rb.resource_type = 'environment'
  AND rb.user_id = $2
  AND rb.group_id IS NULL
`

type GetEnvironmentsWithUserRoleBindingsParams struct {
	SecretGroupID uuid.UUID     `json:"secret_group_id"`
	UserID        uuid.NullUUID `json:"user_id"`
}

type GetEnvironmentsWithUserRoleBindingsRow struct {
	ID             uuid.UUID      `json:"id"`
	Name           string         `json:"name"`
	Description    sql.NullString `json:"description"`
	SecretGroupID  uuid.UUID      `json:"secret_group_id"`
	OrganizationID uuid.UUID      `json:"organization_id"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

// Find all environments where the revoked user has role bindings
func (q *Queries) GetEnvironmentsWithUserRoleBindings(ctx context.Context, arg GetEnvironmentsWithUserRoleBindingsParams) ([]GetEnvironmentsWithUserRoleBindingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnvironmentsWithUserRoleBindings, arg.SecretGroupID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnvironmentsWithUserRoleBindingsRow
	for rows.Next() {
		var i GetEnvironmentsWithUserRoleBindingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.SecretGroupID,
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationOwner = `-- name: GetOrganizationOwner :one


SELECT 
    rb.user_id,
    u.name as user_name,
    u.email as user_email
FROM role_bindings rb
INNER JOIN users u ON rb.user_id = u.id
WHERE rb.resource_type = 'organization'
  AND rb.resource_id = $1
  AND rb.role = 'owner'
  AND rb.group_id IS NULL
LIMIT 1
`

type GetOrganizationOwnerRow struct {
	UserID    uuid.NullUUID  `json:"user_id"`
	UserName  sql.NullString `json:"user_name"`
	UserEmail sql.NullString `json:"user_email"`
}

// Ownership Transfer Queries for RBAC System
// These queries handle ownership transfer when revoking role bindings
// ============================================================================
// 1. GET PARENT RESOURCE OWNER
// ============================================================================
// Get the owner of an organization from role_bindings table
func (q *Queries) GetOrganizationOwner(ctx context.Context, resourceID uuid.UUID) (GetOrganizationOwnerRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationOwner, resourceID)
	var i GetOrganizationOwnerRow
	err := row.Scan(&i.UserID, &i.UserName, &i.UserEmail)
	return i, err
}

const getResourceRoleBindings = `-- name: GetResourceRoleBindings :many
SELECT 
    rb.user_id,
    rb.role,
    rb.resource_type,
    rb.resource_id,
    u.name as user_name,
    u.email as user_email
FROM role_bindings rb
INNER JOIN users u ON rb.user_id = u.id
WHERE rb.resource_type = $1
  AND rb.resource_id = $2
ORDER BY rb.role DESC, u.name
`

type GetResourceRoleBindingsParams struct {
	ResourceType ResourceType `json:"resource_type"`
	ResourceID   uuid.UUID    `json:"resource_id"`
}

type GetResourceRoleBindingsRow struct {
	UserID       uuid.NullUUID  `json:"user_id"`
	Role         UserRole       `json:"role"`
	ResourceType ResourceType   `json:"resource_type"`
	ResourceID   uuid.UUID      `json:"resource_id"`
	UserName     sql.NullString `json:"user_name"`
	UserEmail    sql.NullString `json:"user_email"`
}

// Get all role bindings for a specific resource
func (q *Queries) GetResourceRoleBindings(ctx context.Context, arg GetResourceRoleBindingsParams) ([]GetResourceRoleBindingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getResourceRoleBindings, arg.ResourceType, arg.ResourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceRoleBindingsRow
	for rows.Next() {
		var i GetResourceRoleBindingsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Role,
			&i.ResourceType,
			&i.ResourceID,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecretGroupOwner = `-- name: GetSecretGroupOwner :one
SELECT 
    rb.user_id,
    u.name as user_name,
    u.email as user_email
FROM role_bindings rb
INNER JOIN users u ON rb.user_id = u.id
WHERE rb.resource_type = 'secret_group'
  AND rb.resource_id = $1
  AND rb.role = 'owner'
  AND rb.group_id IS NULL
LIMIT 1
`

type GetSecretGroupOwnerRow struct {
	UserID    uuid.NullUUID  `json:"user_id"`
	UserName  sql.NullString `json:"user_name"`
	UserEmail sql.NullString `json:"user_email"`
}

// Get the owner of a secret group from role_bindings table
func (q *Queries) GetSecretGroupOwner(ctx context.Context, resourceID uuid.UUID) (GetSecretGroupOwnerRow, error) {
	row := q.db.QueryRowContext(ctx, getSecretGroupOwner, resourceID)
	var i GetSecretGroupOwnerRow
	err := row.Scan(&i.UserID, &i.UserName, &i.UserEmail)
	return i, err
}

const getSecretGroupsWithGroupRoleBindings = `-- name: GetSecretGroupsWithGroupRoleBindings :many
SELECT DISTINCT
    sg.id,
    sg.name,
    sg.description,
    sg.organization_id,
    sg.created_at,
    sg.updated_at
FROM secret_groups sg
INNER JOIN role_bindings rb ON sg.id = rb.resource_id
INNER JOIN user_group_members ugm ON rb.user_id = ugm.user_id
WHERE sg.organization_id = $1
  AND rb.resource_type = 'secret_group'
  AND ugm.user_group_id = $2
  AND rb.group_id IS NULL
`

type GetSecretGroupsWithGroupRoleBindingsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	UserGroupID    uuid.UUID `json:"user_group_id"`
}

// Find all secret groups where members of the revoked group have role bindings
func (q *Queries) GetSecretGroupsWithGroupRoleBindings(ctx context.Context, arg GetSecretGroupsWithGroupRoleBindingsParams) ([]SecretGroup, error) {
	rows, err := q.db.QueryContext(ctx, getSecretGroupsWithGroupRoleBindings, arg.OrganizationID, arg.UserGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecretGroup
	for rows.Next() {
		var i SecretGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecretGroupsWithUserRoleBindings = `-- name: GetSecretGroupsWithUserRoleBindings :many

SELECT 
    sg.id,
    sg.name,
    sg.description,
    sg.organization_id,
    sg.created_at,
    sg.updated_at
FROM secret_groups sg
INNER JOIN role_bindings rb ON sg.id = rb.resource_id
WHERE sg.organization_id = $1
  AND rb.resource_type = 'secret_group'
  AND rb.user_id = $2
  AND rb.group_id IS NULL
`

type GetSecretGroupsWithUserRoleBindingsParams struct {
	OrganizationID uuid.UUID     `json:"organization_id"`
	UserID         uuid.NullUUID `json:"user_id"`
}

// ============================================================================
// 2. FIND CHILD RESOURCES WITH ROLE BINDINGS BY REVOKED USER/GROUP
// ============================================================================
// Find all secret groups where the revoked user has role bindings
func (q *Queries) GetSecretGroupsWithUserRoleBindings(ctx context.Context, arg GetSecretGroupsWithUserRoleBindingsParams) ([]SecretGroup, error) {
	rows, err := q.db.QueryContext(ctx, getSecretGroupsWithUserRoleBindings, arg.OrganizationID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecretGroup
	for rows.Next() {
		var i SecretGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferEnvironmentRoleBindingOwnership = `-- name: TransferEnvironmentRoleBindingOwnership :exec
UPDATE role_bindings
SET user_id = $2,
    updated_at = now()
WHERE resource_type = 'environment'
  AND resource_id = $1
  AND role = 'owner'
`

type TransferEnvironmentRoleBindingOwnershipParams struct {
	ResourceID uuid.UUID     `json:"resource_id"`
	UserID     uuid.NullUUID `json:"user_id"`
}

// Transfer ownership of an environment by updating the role binding
func (q *Queries) TransferEnvironmentRoleBindingOwnership(ctx context.Context, arg TransferEnvironmentRoleBindingOwnershipParams) error {
	_, err := q.db.ExecContext(ctx, transferEnvironmentRoleBindingOwnership, arg.ResourceID, arg.UserID)
	return err
}

const transferSecretGroupRoleBindingOwnership = `-- name: TransferSecretGroupRoleBindingOwnership :exec

UPDATE role_bindings
SET user_id = $2,
    updated_at = now()
WHERE resource_type = 'secret_group'
  AND resource_id = $1
  AND role = 'owner'
`

type TransferSecretGroupRoleBindingOwnershipParams struct {
	ResourceID uuid.UUID     `json:"resource_id"`
	UserID     uuid.NullUUID `json:"user_id"`
}

// ============================================================================
// 3. TRANSFER OWNERSHIP BY UPDATING ROLE BINDINGS
// ============================================================================
// Transfer ownership of a secret group by updating the role binding
func (q *Queries) TransferSecretGroupRoleBindingOwnership(ctx context.Context, arg TransferSecretGroupRoleBindingOwnershipParams) error {
	_, err := q.db.ExecContext(ctx, transferSecretGroupRoleBindingOwnership, arg.ResourceID, arg.UserID)
	return err
}

const validateResourceOwnership = `-- name: ValidateResourceOwnership :one

SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM role_bindings 
            WHERE resource_type = $1 
              AND resource_id = $2 
              AND role = 'owner'
        ) THEN true
        ELSE false
    END as has_owner
`

type ValidateResourceOwnershipParams struct {
	ResourceType ResourceType `json:"resource_type"`
	ResourceID   uuid.UUID    `json:"resource_id"`
}

// ============================================================================
// 6. VALIDATION QUERIES
// ============================================================================
// Validate that a resource exists and has an owner
func (q *Queries) ValidateResourceOwnership(ctx context.Context, arg ValidateResourceOwnershipParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, validateResourceOwnership, arg.ResourceType, arg.ResourceID)
	var has_owner bool
	err := row.Scan(&has_owner)
	return has_owner, err
}
