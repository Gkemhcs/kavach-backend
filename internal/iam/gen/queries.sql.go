// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package iam_db

import (
	"context"

	"github.com/google/uuid"
)

const createRoleBinding = `-- name: CreateRoleBinding :one
INSERT INTO role_bindings (
  user_id,
  role,
  resource_type,
  resource_id,
  organization_id,
  secret_group_id,
  environment_id
)
VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, role, resource_type, resource_id, created_at, updated_at, organization_id, secret_group_id, environment_id, group_id
`

type CreateRoleBindingParams struct {
	UserID         uuid.NullUUID `json:"user_id"`
	Role           UserRole      `json:"role"`
	ResourceType   ResourceType  `json:"resource_type"`
	ResourceID     uuid.UUID     `json:"resource_id"`
	OrganizationID uuid.UUID     `json:"organization_id"`
	SecretGroupID  uuid.NullUUID `json:"secret_group_id"`
	EnvironmentID  uuid.NullUUID `json:"environment_id"`
}

// CreateRoleBinding: Creates a new role binding for a user on a specific resource
// Used internally for creating role bindings with explicit user IDs and resource references
// Returns the complete role binding record including generated ID and timestamps
func (q *Queries) CreateRoleBinding(ctx context.Context, arg CreateRoleBindingParams) (RoleBinding, error) {
	row := q.db.QueryRowContext(ctx, createRoleBinding,
		arg.UserID,
		arg.Role,
		arg.ResourceType,
		arg.ResourceID,
		arg.OrganizationID,
		arg.SecretGroupID,
		arg.EnvironmentID,
	)
	var i RoleBinding
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Role,
		&i.ResourceType,
		&i.ResourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.SecretGroupID,
		&i.EnvironmentID,
		&i.GroupID,
	)
	return i, err
}

const deleteRoleBinding = `-- name: DeleteRoleBinding :exec
DELETE FROM role_bindings
WHERE resource_type = $1
  AND resource_id = $2
`

type DeleteRoleBindingParams struct {
	ResourceType ResourceType `json:"resource_type"`
	ResourceID   uuid.UUID    `json:"resource_id"`
}

// DeleteRoleBinding: Removes a specific role binding from the system
// Deletes the exact role binding identified by the composite key
func (q *Queries) DeleteRoleBinding(ctx context.Context, arg DeleteRoleBindingParams) error {
	_, err := q.db.ExecContext(ctx, deleteRoleBinding, arg.ResourceType, arg.ResourceID)
	return err
}

const getRoleBinding = `-- name: GetRoleBinding :one
SELECT id, user_id, role, resource_type, resource_id, created_at, updated_at, organization_id, secret_group_id, environment_id, group_id FROM role_bindings
WHERE user_id = $1
  AND role = $2
  AND resource_type = $3
  AND resource_id = $4
`

type GetRoleBindingParams struct {
	UserID       uuid.NullUUID `json:"user_id"`
	Role         UserRole      `json:"role"`
	ResourceType ResourceType  `json:"resource_type"`
	ResourceID   uuid.UUID     `json:"resource_id"`
}

// GetRoleBinding: Retrieves a specific role binding by its composite key
// Used for validation and lookup operations when all binding parameters are known
// Returns complete role binding record if found
func (q *Queries) GetRoleBinding(ctx context.Context, arg GetRoleBindingParams) (RoleBinding, error) {
	row := q.db.QueryRowContext(ctx, getRoleBinding,
		arg.UserID,
		arg.Role,
		arg.ResourceType,
		arg.ResourceID,
	)
	var i RoleBinding
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Role,
		&i.ResourceType,
		&i.ResourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.SecretGroupID,
		&i.EnvironmentID,
		&i.GroupID,
	)
	return i, err
}

const listAccessibleEnvironments = `-- name: ListAccessibleEnvironments :many
SELECT 
  rb.environment_id AS id,
  e.name,
  sg.name AS secret_group_name,
  rb.role AS role        
FROM role_bindings AS rb 
INNER JOIN environments AS e ON rb.environment_id = e.id
INNER JOIN secret_groups AS sg ON rb.secret_group_id = sg.id
WHERE 
  rb.user_id = $1 
  AND rb.organization_id = $2
  AND rb.secret_group_id = $3
`

type ListAccessibleEnvironmentsParams struct {
	UserID         uuid.NullUUID `json:"user_id"`
	OrganizationID uuid.UUID     `json:"organization_id"`
	SecretGroupID  uuid.NullUUID `json:"secret_group_id"`
}

type ListAccessibleEnvironmentsRow struct {
	ID              uuid.NullUUID `json:"id"`
	Name            string        `json:"name"`
	SecretGroupName string        `json:"secret_group_name"`
	Role            UserRole      `json:"role"`
}

// ListAccessibleEnvironments: Retrieves all environments within a secret group that a user has access to
// Joins with environments and secret_groups tables to get environment and group details
// Filters for environment-level permissions within the specified secret group
func (q *Queries) ListAccessibleEnvironments(ctx context.Context, arg ListAccessibleEnvironmentsParams) ([]ListAccessibleEnvironmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccessibleEnvironments, arg.UserID, arg.OrganizationID, arg.SecretGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccessibleEnvironmentsRow
	for rows.Next() {
		var i ListAccessibleEnvironmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SecretGroupName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccessibleOrganizations = `-- name: ListAccessibleOrganizations :many
SELECT 
  rb.organization_id AS id,
  o.name as org_name,
  rb.role AS role      
FROM role_bindings AS rb 
INNER JOIN organizations AS o ON rb.organization_id = o.id
WHERE 
  rb.user_id = $1 
  AND rb.environment_id IS NULL 
  AND rb.secret_group_id IS NULL
`

type ListAccessibleOrganizationsRow struct {
	ID      uuid.UUID `json:"id"`
	OrgName string    `json:"org_name"`
	Role    UserRole  `json:"role"`
}

// ListAccessibleOrganizations: Retrieves all organizations that a user has access to
// Joins with organizations table to get organization details along with user's role
// Filters for organization-level permissions (no secret_group_id or environment_id)
func (q *Queries) ListAccessibleOrganizations(ctx context.Context, userID uuid.NullUUID) ([]ListAccessibleOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccessibleOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccessibleOrganizationsRow
	for rows.Next() {
		var i ListAccessibleOrganizationsRow
		if err := rows.Scan(&i.ID, &i.OrgName, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccessibleSecretGroups = `-- name: ListAccessibleSecretGroups :many
SELECT 
  rb.secret_group_id AS id,
  sg.name as name,
  o.name AS organization_name,
  rb.role AS role      
FROM role_bindings AS rb 
INNER JOIN secret_groups AS sg ON rb.secret_group_id = sg.id
INNER JOIN organizations AS o ON rb.organization_id = o.id
WHERE 
  rb.user_id = $1 
  AND rb.environment_id IS NULL 
  AND rb.organization_id = $2
`

type ListAccessibleSecretGroupsParams struct {
	UserID         uuid.NullUUID `json:"user_id"`
	OrganizationID uuid.UUID     `json:"organization_id"`
}

type ListAccessibleSecretGroupsRow struct {
	ID               uuid.NullUUID `json:"id"`
	Name             string        `json:"name"`
	OrganizationName string        `json:"organization_name"`
	Role             UserRole      `json:"role"`
}

// ListAccessibleSecretGroups: Retrieves all secret groups within an organization that a user has access to
// Joins with secret_groups and organizations tables to get group and org details
// Filters for secret group-level permissions within the specified organization
func (q *Queries) ListAccessibleSecretGroups(ctx context.Context, arg ListAccessibleSecretGroupsParams) ([]ListAccessibleSecretGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccessibleSecretGroups, arg.UserID, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccessibleSecretGroupsRow
	for rows.Next() {
		var i ListAccessibleSecretGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganizationName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE role_bindings
SET role = $5,
    updated_at = now()
WHERE user_id = $1
  AND resource_type = $2
  AND resource_id = $3
  AND role = $4
`

type UpdateUserRoleParams struct {
	UserID       uuid.NullUUID `json:"user_id"`
	ResourceType ResourceType  `json:"resource_type"`
	ResourceID   uuid.UUID     `json:"resource_id"`
	Role         UserRole      `json:"role"`
	Role_2       UserRole      `json:"role_2"`
}

// UpdateUserRole: Updates the role level for an existing role binding
// Changes the role while preserving the binding relationship and updating the timestamp
func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRole,
		arg.UserID,
		arg.ResourceType,
		arg.ResourceID,
		arg.Role,
		arg.Role_2,
	)
	return err
}
