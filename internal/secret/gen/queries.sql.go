// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package secretdb

import (
	"context"

	"github.com/google/uuid"
)

const createSecretVersion = `-- name: CreateSecretVersion :one
INSERT INTO secret_versions (environment_id, commit_message)
VALUES ($1, $2)
RETURNING id, environment_id, commit_message, created_at
`

type CreateSecretVersionParams struct {
	EnvironmentID uuid.UUID `json:"environment_id"`
	CommitMessage string    `json:"commit_message"`
}

func (q *Queries) CreateSecretVersion(ctx context.Context, arg CreateSecretVersionParams) (SecretVersion, error) {
	row := q.db.QueryRowContext(ctx, createSecretVersion, arg.EnvironmentID, arg.CommitMessage)
	var i SecretVersion
	err := row.Scan(
		&i.ID,
		&i.EnvironmentID,
		&i.CommitMessage,
		&i.CreatedAt,
	)
	return i, err
}

const diffSecretVersions = `-- name: DiffSecretVersions :many
SELECT 
    COALESCE(s1.name, s2.name) as name,
    s1.value_encrypted AS value_v1, 
    s2.value_encrypted AS value_v2
FROM (
    SELECT name, value_encrypted 
    FROM secrets 
    WHERE secrets.version_id = $1
) s1
FULL OUTER JOIN (
    SELECT name, value_encrypted 
    FROM secrets 
    WHERE secrets.version_id = $2
) s2 ON s1.name = s2.name
`

type DiffSecretVersionsParams struct {
	VersionID   string `json:"version_id"`
	VersionID_2 string `json:"version_id_2"`
}

type DiffSecretVersionsRow struct {
	Name    string `json:"name"`
	ValueV1 []byte `json:"value_v1"`
	ValueV2 []byte `json:"value_v2"`
}

func (q *Queries) DiffSecretVersions(ctx context.Context, arg DiffSecretVersionsParams) ([]DiffSecretVersionsRow, error) {
	rows, err := q.db.QueryContext(ctx, diffSecretVersions, arg.VersionID, arg.VersionID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DiffSecretVersionsRow
	for rows.Next() {
		var i DiffSecretVersionsRow
		if err := rows.Scan(&i.Name, &i.ValueV1, &i.ValueV2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecretVersion = `-- name: GetSecretVersion :one
SELECT id, environment_id, commit_message, created_at FROM secret_versions WHERE id = $1
`

func (q *Queries) GetSecretVersion(ctx context.Context, id string) (SecretVersion, error) {
	row := q.db.QueryRowContext(ctx, getSecretVersion, id)
	var i SecretVersion
	err := row.Scan(
		&i.ID,
		&i.EnvironmentID,
		&i.CommitMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getSecretsForVersion = `-- name: GetSecretsForVersion :many
SELECT id, name, value_encrypted FROM secrets WHERE version_id = $1
`

type GetSecretsForVersionRow struct {
	ID             uuid.UUID `json:"id"`
	Name           string    `json:"name"`
	ValueEncrypted []byte    `json:"value_encrypted"`
}

func (q *Queries) GetSecretsForVersion(ctx context.Context, versionID string) ([]GetSecretsForVersionRow, error) {
	rows, err := q.db.QueryContext(ctx, getSecretsForVersion, versionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSecretsForVersionRow
	for rows.Next() {
		var i GetSecretsForVersionRow
		if err := rows.Scan(&i.ID, &i.Name, &i.ValueEncrypted); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSecret = `-- name: InsertSecret :exec
INSERT INTO secrets (version_id, name, value_encrypted)
VALUES ($1, $2, $3)
ON CONFLICT (version_id, name) DO UPDATE SET value_encrypted = EXCLUDED.value_encrypted
`

type InsertSecretParams struct {
	VersionID      string `json:"version_id"`
	Name           string `json:"name"`
	ValueEncrypted []byte `json:"value_encrypted"`
}

func (q *Queries) InsertSecret(ctx context.Context, arg InsertSecretParams) error {
	_, err := q.db.ExecContext(ctx, insertSecret, arg.VersionID, arg.Name, arg.ValueEncrypted)
	return err
}

const listSecretVersions = `-- name: ListSecretVersions :many
SELECT id, environment_id, commit_message, created_at FROM secret_versions WHERE environment_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListSecretVersions(ctx context.Context, environmentID uuid.UUID) ([]SecretVersion, error) {
	rows, err := q.db.QueryContext(ctx, listSecretVersions, environmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecretVersion
	for rows.Next() {
		var i SecretVersion
		if err := rows.Scan(
			&i.ID,
			&i.EnvironmentID,
			&i.CommitMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rollbackSecretsToVersion = `-- name: RollbackSecretsToVersion :exec
INSERT INTO secrets (version_id, name, value_encrypted)
SELECT $1::VARCHAR(8), s.name, s.value_encrypted
FROM secrets s
WHERE s.version_id = $2
ON CONFLICT (version_id, name) DO UPDATE SET value_encrypted = EXCLUDED.value_encrypted
`

type RollbackSecretsToVersionParams struct {
	Column1   string `json:"column_1"`
	VersionID string `json:"version_id"`
}

func (q *Queries) RollbackSecretsToVersion(ctx context.Context, arg RollbackSecretsToVersionParams) error {
	_, err := q.db.ExecContext(ctx, rollbackSecretsToVersion, arg.Column1, arg.VersionID)
	return err
}
